{"version":3,"file":"pipelinedQueryExecutionContext.js","sourceRoot":"","sources":["../../src/queryExecutionContext/pipelinedQueryExecutionContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../ClientContext\";\nimport { Response, FeedOptions } from \"../request\";\nimport { PartitionedQueryExecutionInfo } from \"../request/ErrorResponse\";\nimport { CosmosHeaders } from \"./CosmosHeaders\";\nimport { OffsetLimitEndpointComponent } from \"./EndpointComponent/OffsetLimitEndpointComponent\";\nimport { OrderByEndpointComponent } from \"./EndpointComponent/OrderByEndpointComponent\";\nimport { OrderedDistinctEndpointComponent } from \"./EndpointComponent/OrderedDistinctEndpointComponent\";\nimport { UnorderedDistinctEndpointComponent } from \"./EndpointComponent/UnorderedDistinctEndpointComponent\";\nimport { GroupByEndpointComponent } from \"./EndpointComponent/GroupByEndpointComponent\";\nimport { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { OrderByQueryExecutionContext } from \"./orderByQueryExecutionContext\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { GroupByValueEndpointComponent } from \"./EndpointComponent/GroupByValueEndpointComponent\";\n\n/** @hidden */\nexport class PipelinedQueryExecutionContext implements ExecutionContext {\n  private fetchBuffer: any[];\n  private fetchMoreRespHeaders: CosmosHeaders;\n  private endpoint: ExecutionContext;\n  private pageSize: number;\n  private static DEFAULT_PAGE_SIZE = 10;\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: any, // TODO: any query\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo\n  ) {\n    this.endpoint = null;\n    this.pageSize = options[\"maxItemCount\"];\n    if (this.pageSize === undefined) {\n      this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\n    }\n\n    // Pick between parallel vs order by execution context\n    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;\n    if (Array.isArray(sortOrders) && sortOrders.length > 0) {\n      // Need to wrap orderby execution context in endpoint component, since the data is nested as a \\\n      //      \"payload\" property.\n      this.endpoint = new OrderByEndpointComponent(\n        new OrderByQueryExecutionContext(\n          this.clientContext,\n          this.collectionLink,\n          this.query,\n          this.options,\n          this.partitionedQueryExecutionInfo\n        )\n      );\n    } else {\n      this.endpoint = new ParallelQueryExecutionContext(\n        this.clientContext,\n        this.collectionLink,\n        this.query,\n        this.options,\n        this.partitionedQueryExecutionInfo\n      );\n    }\n    if (\n      Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length > 0 ||\n      partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 ||\n      partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0\n    ) {\n      if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {\n        this.endpoint = new GroupByValueEndpointComponent(\n          this.endpoint,\n          partitionedQueryExecutionInfo.queryInfo\n        );\n      } else {\n        this.endpoint = new GroupByEndpointComponent(\n          this.endpoint,\n          partitionedQueryExecutionInfo.queryInfo\n        );\n      }\n    }\n    // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N\n    const top = partitionedQueryExecutionInfo.queryInfo.top;\n    if (typeof top === \"number\") {\n      this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);\n    }\n\n    // If offset+limit then add that to the pipeline\n    const limit = partitionedQueryExecutionInfo.queryInfo.limit;\n    const offset = partitionedQueryExecutionInfo.queryInfo.offset;\n    if (typeof limit === \"number\" && typeof offset === \"number\") {\n      this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);\n    }\n\n    // If distinct then add that to the pipeline\n    const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n    if (distinctType === \"Ordered\") {\n      this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);\n    }\n    if (distinctType === \"Unordered\") {\n      this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);\n    }\n  }\n\n  public async nextItem(): Promise<Response<any>> {\n    return this.endpoint.nextItem();\n  }\n\n  // Removed callback here beacuse it wouldn't have ever worked...\n  public hasMoreResults(): boolean {\n    return this.endpoint.hasMoreResults();\n  }\n\n  public async fetchMore(): Promise<Response<any>> {\n    // if the wrapped endpoint has different implementation for fetchMore use that\n    // otherwise use the default implementation\n    if (typeof this.endpoint.fetchMore === \"function\") {\n      return this.endpoint.fetchMore();\n    } else {\n      this.fetchBuffer = [];\n      this.fetchMoreRespHeaders = getInitialHeader();\n      return this._fetchMoreImplementation();\n    }\n  }\n\n  private async _fetchMoreImplementation(): Promise<Response<any>> {\n    try {\n      const { result: item, headers } = await this.endpoint.nextItem();\n      mergeHeaders(this.fetchMoreRespHeaders, headers);\n      if (item === undefined) {\n        // no more results\n        if (this.fetchBuffer.length === 0) {\n          return {\n            result: undefined,\n            headers: this.fetchMoreRespHeaders\n          };\n        } else {\n          // Just give what we have\n          const temp = this.fetchBuffer;\n          this.fetchBuffer = [];\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        }\n      } else {\n        // append the result\n        this.fetchBuffer.push(item);\n        if (this.fetchBuffer.length >= this.pageSize) {\n          // fetched enough results\n          const temp = this.fetchBuffer.slice(0, this.pageSize);\n          this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        } else {\n          // recursively fetch more\n          // TODO: is recursion a good idea?\n          return this._fetchMoreImplementation();\n        }\n      }\n    } catch (err) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err) {\n        throw err;\n      }\n    }\n  }\n}\n"]}